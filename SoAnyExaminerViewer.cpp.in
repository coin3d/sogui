/**************************************************************************\
 *
 *  Copyright (C) 2000 by Systems in Motion.  All rights reserved.
 *
 *  This file is part of the Coin library.
 *
 *  This file may be distributed under the terms of the Q Public License
 *  as defined by Troll Tech AS of Norway and appearing in the file
 *  LICENSE.QPL included in the packaging of this file.
 *
 *  If you want to use Coin in applications not covered by licenses
 *  compatible with the QPL, you can contact SIM to aquire a
 *  Professional Edition license for Coin.
 *
 *  Systems in Motion AS, Prof. Brochs gate 6, N-7030 Trondheim, NORWAY
 *  http://www.sim.no/ sales@sim.no Voice: +47 22114160 Fax: +47 67172912
 *
\**************************************************************************/

// @configure_input@

#if SO@GUI@_DEBUG
static const char rcsid[] =
  "$Id$";
#endif // SO@GUI@_DEBUG

/*!
  \class SoAnyExaminerViewer SoAnyExaminerViewer.h
  \brief The SoAnyExaminerViewer class is a collection of common functions for
  all the ExaminerViewer components for Coin.
*/

#include <assert.h>
#include <math.h>

#ifdef _WIN32
#include <windows.h>
#endif // _WIN32
#include <GL/gl.h>

#include <Inventor/SbTime.h>
#include <Inventor/errors/SoDebugError.h>
#include <Inventor/nodes/SoOrthographicCamera.h>
#include <Inventor/nodes/SoPerspectiveCamera.h>
#include <Inventor/projectors/SbSphereSheetProjector.h>
#include <Inventor/projectors/SbSpherePlaneProjector.h>
#include <Inventor/events/SoKeyboardEvent.h>
#include <Inventor/events/SoMouseButtonEvent.h>
#include <Inventor/events/SoLocation2Event.h>
#include <Inventor/events/SoMotion3Event.h>

#include <Inventor/@Gui@/So@Gui@Basic.h>
#include <Inventor/@Gui@/viewers/So@Gui@ExaminerViewer.h>
#include <Inventor/@Gui@/viewers/SoAnyExaminerViewer.h>

#ifdef HAVE_CONFIG_H
#include <config.h>
#endif // HAVE_CONFIG_H

// Bitmap representations of an "X", a "Y" and a "Z" for the axis cross.
static GLubyte xbmp[] = { 0x11,0x11,0x0a,0x04,0x0a,0x11,0x11 };
static GLubyte ybmp[] = { 0x04,0x04,0x04,0x04,0x0a,0x11,0x11 };
static GLubyte zbmp[] = { 0x1f,0x10,0x08,0x04,0x02,0x01,0x1f };

#ifndef M_PI
#define M_PI 3.1415926535f
#endif // ! M_PI

#define MOUSEBUTTON_EVENT  SoMouseButtonEvent::getClassTypeId()
#define LOCATION2_EVENT    SoLocation2Event::getClassTypeId()
#define MOTION3_EVENT      SoMotion3Event::getClassTypeId()
#define KEYBOARD_EVENT     SoKeyboardEvent::getClassTypeId()

// ************************************************************************

/*!
*/

SoAnyExaminerViewer::SoAnyExaminerViewer(
  So@Gui@ExaminerViewer * const container )
: viewer( container )
{
  assert( container != NULL );

  this->prevRedrawTime = SbTime::getTimeOfDay();
  this->spinanimatingallowed = TRUE;
  this->spinanimating = FALSE;
  this->spinsamplecounter = 0;
  this->spinincrement = SbRotation::identity();

  // FIXME: use a smaller sphere than the default one to have a larger
  // area close to the borders that gives us "z-axis rotation"?
  // 990425 mortene.
  this->spinprojector = new SbSphereSheetProjector;
  SbViewVolume volume;
  volume.ortho( -1, 1, -1, 1, -1, 1 );
  this->spinprojector->setViewVolume( volume );

  this->axiscrossEnabled = FALSE;
  this->axiscrossSize = 25;

  this->spinRotation.setValue( SbVec3f( 0, 0, -1 ), 0 );

  this->log.size = 16;
  this->log.position = new SbVec2s [ 16 ];
  this->log.time = new SbTime [ 16 ];
  this->log.historysize = 0;
  this->button1Down = FALSE;
  this->button3Down = FALSE;
  this->controlDown = FALSE;
  this->motion3OnCamera = TRUE;
} // SoAnyExaminerViewer()

/*!
*/

SoAnyExaminerViewer::~SoAnyExaminerViewer(
  void )
{
  delete this->spinprojector;
  delete this->log.position;
  delete this->log.time;
} // ~SoAnyExaminerViewer()

// ************************************************************************

/*!
  The "rotX" wheel is the wheel on the left decoration on the examiner
  viewer.  This function translates interaction with the "rotX" wheel into
  camera movement.
*/

float
SoAnyExaminerViewer::rotXWheelMotion(
  float value,
  float oldvalue )
{
  SoCamera * camera = this->viewer->getCamera();
  if ( camera == NULL ) return 0.0f; // can happen for empty scenegraph

  SbVec3f dir;
  camera->orientation.getValue().multVec( SbVec3f( 0, 0, -1 ), dir );

  SbVec3f focalpoint = camera->position.getValue() +
    camera->focalDistance.getValue() * dir;

  camera->orientation = SbRotation( SbVec3f( -1, 0, 0 ), value - oldvalue ) *
    camera->orientation.getValue();

  camera->orientation.getValue().multVec( SbVec3f(0, 0, -1), dir );
  camera->position = focalpoint - camera->focalDistance.getValue() * dir;

  return value;
} // rotXWheelMotion()

/*!
  The "rotY" wheel is the wheel on the bottom decoration on the examiner
  viewer.  This function translates interaction with the "rotX" wheel into
  camera movement.
*/

float
SoAnyExaminerViewer::rotYWheelMotion(
  float value,
  float oldvalue )
{
  SoCamera * camera = this->viewer->getCamera();
  if ( camera == NULL ) return 0.0f; // can happen for empty scenegraph

  SbVec3f dir;
  camera->orientation.getValue().multVec(SbVec3f(0, 0, -1), dir);

  SbVec3f focalpoint = camera->position.getValue() +
    camera->focalDistance.getValue() * dir;

  camera->orientation = SbRotation( SbVec3f( 0, 1, 0 ), oldvalue - value ) *
    camera->orientation.getValue();

  camera->orientation.getValue().multVec( SbVec3f(0, 0, -1), dir );
  camera->position = focalpoint - camera->focalDistance.getValue() * dir;

  return value;
} // rotYWheelMotion()

// ************************************************************************

/*!
  Decide if it should be possible to start a spin animation of the model in
  the viewer by releasing the mouse button while dragging.

  If the \c on flag is \c FALSE and we're currently animating, the spin
  will be stopped.

  \sa isAnimationEnabled
*/

void
SoAnyExaminerViewer::setAnimationEnabled(
  const SbBool enable )
{
  this->spinanimatingallowed = enable;
  if ( ! enable && this->isAnimating() )
    this->stopAnimating();
} // setAnimationEnabled()

// *************************************************************************

/*!
  Query whether or not it is possible to start a spinning animation by
  releasing the left mouse button while dragging the mouse.

  \sa setAnimationEnabled
*/

SbBool
SoAnyExaminerViewer::isAnimationEnabled(
  void ) const
{
  return this->spinanimatingallowed;
} // isAnimationEnabled()

// *************************************************************************

/*!
  Stop the model from spinning.
*/

void
SoAnyExaminerViewer::stopAnimating(
  void )
{
  if ( this->spinanimating ) {
    this->spinanimating = FALSE;
    viewer->interactiveCountDec();
  }
#if SO@GUI@_DEBUG
  else
    SoDebugError::postWarning( "So@Gui@ExaminerViewer::stopAnimating",
      "not animating" );
#endif // SO@GUI@_DEBUG
} // stopAnimating()

// *************************************************************************

/*!
  Query if the model in the viewer is currently in spinning mode after
  a user drag.
*/

SbBool
SoAnyExaminerViewer::isAnimating(
  void ) const
{
  return this->spinanimating;
} // isAnimating()

// ************************************************************************

/*!
  Set the flag deciding whether or not to show the axis cross.

  \sa isFeedbackVisible, getFeedbackSize, setFeedbackSize
*/

void
SoAnyExaminerViewer::setFeedbackVisibility(
  const SbBool enable )
{
  if ( enable == this->axiscrossEnabled ) {
#if SO@GUI@_DEBUG
    SoDebugError::postWarning( "So@Gui@ExaminerViewer::setFeedbackVisibility",
      "feedback visibility already set to %s", enable ? "TRUE" : "FALSE" );
#endif // SO@GUI@_DEBUG
    return;
  }
  this->axiscrossEnabled = enable;

  if ( viewer->isViewing() )
    viewer->scheduleRedraw();
} // setFeedbackVisibility()

/*!
  Check if the feedback axis cross is visible.

  \sa setFeedbackVisibility, getFeedbackSize, setFeedbackSize
*/

SbBool
SoAnyExaminerViewer::isFeedbackVisible(
  void ) const
{
  return this->axiscrossEnabled;
} // isFeedbackVisibility()

// ************************************************************************

/*!
  Set the size of the feedback axiscross.  The value is interpreted as
  an approximate percentage chunk of the dimensions of the total canvas.

  \sa getFeedbackSize, isFeedbackVisible, setFeedbackVisibility
*/

void
SoAnyExaminerViewer::setFeedbackSize(
  const int size )
{
#if SO@GUI@_DEBUG
  if ( size < 1 ) {
    SoDebugError::postWarning( "So@Gui@ExaminerViewer::setFeedbackSize",
      "the size setting should be larger than 0" );
    return;
  }
#endif // SO@GUI@_DEBUG

  this->axiscrossSize = size;

  if ( this->isFeedbackVisible() && viewer->isViewing() )
    viewer->scheduleRedraw();
} // setFeedbackSize()

/*!
  Return the size of the feedback axis cross. Default is 25.

  \sa setFeedbackSize, isFeedbackVisible, setFeedbackVisibility
*/

int
SoAnyExaminerViewer::getFeedbackSize(
  void ) const
{
  return this->axiscrossSize;
} // getFeedbackSize()

// ************************************************************************

/*!
*/

void
SoAnyExaminerViewer::drawAxisCross(
  void )
{
  // Store GL state.
  glPushAttrib(GL_ALL_ATTRIB_BITS);
  GLfloat depthrange[2];
  glGetFloatv(GL_DEPTH_RANGE, depthrange);
  GLdouble projectionmatrix[16];
  glGetDoublev(GL_PROJECTION_MATRIX, projectionmatrix);

  glDepthFunc(GL_ALWAYS);
  glDepthMask(GL_TRUE);
  glDepthRange(0, 0);
  glEnable(GL_DEPTH_TEST);
  glDisable(GL_LIGHTING);
  glEnable(GL_COLOR_MATERIAL);
  glDisable(GL_BLEND); // Kills transparency.

  // Set the viewport in the OpenGL canvas. Dimensions are calculated
  // as a percentage of the total canvas size.
  SbVec2s view = viewer->getGLSize();
  const int pixelarea =
    int(float(this->axiscrossSize)/100.0f * So@Gui@Min(view[0], view[1]));
#if 0 // middle of canvas
  SbVec2s origin(view[0]/2 - pixelarea/2, view[1]/2 - pixelarea/2);
#endif // middle of canvas
#if 1 // lower right of canvas
  SbVec2s origin(view[0] - pixelarea, 0);
#endif // lower right of canvas
  glViewport(origin[0], origin[1], pixelarea, pixelarea);



  // Set up the projection matrix.
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();

  const float NEARVAL = 0.1f;
  const float FARVAL = 10.0f;
  const float dim = NEARVAL * tan(M_PI/8.0f); // FOV is 45° (45/360 = 1/8)
  glFrustum(-dim, dim, -dim, dim, NEARVAL, FARVAL);


  // Set up the model matrix.
  glMatrixMode(GL_MODELVIEW);
  glPushMatrix();
  SbMatrix mx;
  mx = viewer->getCamera()->orientation.getValue();
  mx = mx.inverse();
  mx[3][2] = -3.5; // Translate away from the projection point (along z axis).
  glLoadMatrixf((float *)mx);


  // Find unit vector end points.
  SbMatrix px;
  glGetFloatv(GL_PROJECTION_MATRIX, (float *)px);
  SbMatrix comb = mx.multRight(px);

  SbVec3f xpos;
  comb.multVecMatrix(SbVec3f(1,0,0), xpos);
  xpos[0] = (1 + xpos[0]) * view[0]/2;
  xpos[1] = (1 + xpos[1]) * view[1]/2;
  SbVec3f ypos;
  comb.multVecMatrix(SbVec3f(0,1,0), ypos);
  ypos[0] = (1 + ypos[0]) * view[0]/2;
  ypos[1] = (1 + ypos[1]) * view[1]/2;
  SbVec3f zpos;
  comb.multVecMatrix(SbVec3f(0,0,1), zpos);
  zpos[0] = (1 + zpos[0]) * view[0]/2;
  zpos[1] = (1 + zpos[1]) * view[1]/2;


  // Render the cross.
  {
    glLineWidth(2.0);

    // FIXME: the code which makes sure we render in the correct order
    // (which we have to do, as Z-buffering is dysfunctional at this
    // stage) is _really_ lousy. A virtual beer to the first hacker
    // who improves this code. 990424 mortene.

    // Bubble sort.. :-}
    float minval = xpos[2];
    float midval = ypos[2];
    float maxval = zpos[2];
    if (minval > midval) So@Gui@Swap( minval, midval );
    if (midval > maxval) So@Gui@Swap( midval, maxval );
    if (minval > midval) So@Gui@Swap( minval, midval );
    assert((minval <= midval) && (midval <= maxval)); // Just checking..
    // Find the order of rendering. Furthest away should render first,
    // so we sort in back-to-front order.
    int xturn = (xpos[2] == minval) ? 2 : ((xpos[2] == midval) ? 1 : 0);
    int yturn = (ypos[2] == minval) ? 2 : ((ypos[2] == midval) ? 1 : 0);
    int zturn = (zpos[2] == minval) ? 2 : ((zpos[2] == midval) ? 1 : 0);

    // In case any of the three planes defined by the axes were
    // parallel with the viewing plane.
    if (yturn == xturn) yturn++;
    if (zturn == xturn) zturn++;
    if (zturn == yturn) zturn++;

    // The code is uglier than Valgerd Svarstad Haugland, but it'd
    // be even more embarrassing if it didn't work correctly.
    assert(xturn != yturn);
    assert(xturn != zturn);
    assert(yturn != zturn);

    for (int i=0; i < 3; i++) {
      glPushMatrix();
      if (xturn == i) {                       // X axis.
        glColor3f( 0.500f, 0.125f, 0.125f );
      } else if (yturn == i) {                // Y axis.
        glRotatef(90, 0, 0, 1);
        glColor3f( 0.125f, 0.500f, 0.125f );
      } else {                                // Z axis.
        glRotatef(-90, 0, 1, 0);
        glColor3f( 0.125f, 0.125f, 0.500f );
      }
      this->drawArrow();
      glPopMatrix();
    }
  }

  // Render axis notation letters ("X", "Y", "Z").
  glMatrixMode(GL_PROJECTION);
  glLoadIdentity();
  glOrtho(0, view[0], 0, view[1], -1, 1);

  glMatrixMode(GL_MODELVIEW);
  glLoadIdentity();

  GLint unpack;
  glGetIntegerv(GL_UNPACK_ALIGNMENT, &unpack);
  glPixelStorei(GL_UNPACK_ALIGNMENT, 1);

  glColor3fv(SbVec3f(0.8f, 0.8f, 0.0f).getValue());

  glRasterPos2d(xpos[0], xpos[1]);
  glBitmap(8, 7, 0, 0, 0, 0, xbmp);
  glRasterPos2d(ypos[0], ypos[1]);
  glBitmap(8, 7, 0, 0, 0, 0, ybmp);
  glRasterPos2d(zpos[0], zpos[1]);
  glBitmap(8, 7, 0, 0, 0, 0, zbmp);

  glPixelStorei(GL_UNPACK_ALIGNMENT, unpack);
  glPopMatrix();

  // Reset original state.

  // FIXME: are these 3 lines really necessary, as we push
  // GL_ALL_ATTRIB_BITS at the start? 20000604 mortene.
  glDepthRange(depthrange[0], depthrange[1]);
  glMatrixMode(GL_PROJECTION);
  glLoadMatrixd(projectionmatrix);

  glPopAttrib();
} // drawAxisCross()

/*!
  \internal

  Draw an arrow for the axis representation directly through OpenGL.
*/

void
SoAnyExaminerViewer::drawArrow( // static
  void )
{
  glBegin(GL_LINES);
  glVertex3f(0, 0, 0);
  glVertex3f(1, 0, 0);
  glEnd();
  glDisable(GL_CULL_FACE);
  glBegin(GL_TRIANGLES);
  glVertex3f(1.0, 0, 0);
  glVertex3f(1.0-1.0/3, +0.5/4, 0);
  glVertex3f(1.0-1.0/3, -0.5/4, 0);
  glVertex3f(1.0, 0, 0);
  glVertex3f(1.0-1.0/3, 0, +0.5/4);
  glVertex3f(1.0-1.0/3, 0, -0.5/4);
  glEnd();
  glBegin(GL_QUADS);
  glVertex3f(1.0-1.0/3, +0.5/4, 0);
  glVertex3f(1.0-1.0/3, 0, +0.5/4);
  glVertex3f(1.0-1.0/3, -0.5/4, 0);
  glVertex3f(1.0-1.0/3, 0, -0.5/4);
  glEnd();
} // drawArrow()

// ************************************************************************

/*!
  \internal

  Rotate the camera by the given amount, then reposition it so we're still
  pointing at the same focal point.
*/

void
SoAnyExaminerViewer::reorientCamera(
  const SbRotation & rot )
{
  SoCamera * cam = this->viewer->getCamera();
  if ( cam == NULL ) return;

  // Find global coordinates of focal point.
  SbVec3f direction;
  cam->orientation.getValue().multVec( SbVec3f(0, 0, -1), direction );
  SbVec3f focalpoint = cam->position.getValue() +
    cam->focalDistance.getValue() * direction;

//  SoDebugError::postWarning("SoAnyExaminerViewer::reorientCamera", "A" );
  // Set new orientation value by accumulating the new rotation.
  
//  fprintf( stdout, "\nrotation : " );
//  rot.print( stdout );
//  fprintf( stdout, "\ncamera   : " );
//  cam->orientation.getValue().print( stdout );
//  fprintf( stdout, "\n" );
//  SoDebugError::postWarning("SoAnyExaminerViewer::reorientCamera", "A" );
  cam->orientation = rot * cam->orientation.getValue();
//  SoDebugError::postWarning("SoAnyExaminerViewer::reorientCamera", "B" );

  // Reposition camera so we are still pointing at the same old focal point.
  cam->orientation.getValue().multVec( SbVec3f(0, 0, -1), direction );
  cam->position = focalpoint - cam->focalDistance.getValue() * direction;
} // reorientCamera()

// ************************************************************************

/*!
  \internal

  Uses the sphere sheet projector to map the mouseposition unto
  a 3D point and find a rotation from this and the last calculated point.
*/

void
SoAnyExaminerViewer::spin(
  const SbVec2f & pointerpos )
{
  if ( this->log.historysize < 2 ) return;
  assert( this->spinprojector != NULL );

  SbVec2s glsize( viewer->getGLSize() );
  SbVec2f lastpos;
  lastpos[0] = float(this->log.position[1][0]) / float(glsize[0]-1);
  lastpos[1] = float(this->log.position[1][1]) / float(glsize[1]-1);

  this->spinprojector->project( lastpos );
  SbRotation r;
  this->spinprojector->projectAndGetRotation( pointerpos, r );
#if 0 // debug
  // FIXME: Trying to track down an annoying (non-critical) bug.
  // 990501 mortene.
  if (r == SbRotation::identity()) {
    SoDebugError::postWarning("So@Gui@ExaminerViewer::spin",
                              "rotation equals identity");
  }
#endif // debug
  r.invert();
//  SoDebugError::postWarning("So@Gui@ExaminerViewer::spin", "reorientCamera" );
  this->reorientCamera( r );

  // Calculate an average angle magnitude value to make the transition
  // to a possible spin animation mode appear smooth.

  SbVec3f dummy_axis, newaxis;
  float acc_angle, newangle;
  this->spinincrement.getValue(dummy_axis, acc_angle);
  acc_angle *= this->spinsamplecounter; // weight
  r.getValue(newaxis, newangle);
  acc_angle += newangle;

  this->spinsamplecounter++;
  acc_angle /= this->spinsamplecounter;
  // FIXME: accumulate and average axis vectors aswell? 990501 mortene.
  this->spinincrement.setValue(newaxis, acc_angle);

  // Don't carry too much baggage, as that'll give unwanted results
  // when the user quickly trigger (as in "click-drag-release") a spin
  // animation.
  if (this->spinsamplecounter > 3) this->spinsamplecounter = 3;
} // spin()

// ************************************************************************

/*!
  \internal

  Move scene parallel with the plane orthogonal to the camera
  direction vector.
*/

void
SoAnyExaminerViewer::pan(
  const SbVec2f & thispos,
  const SbVec2f & prevpos )
{
  SoCamera * cam = viewer->getCamera();
  if ( cam == NULL ) return; // can happen for empty scenegraph
  if ( thispos == prevpos ) {
#if SO@GUI@_DEBUG
    SoDebugError::postInfo( "SoAnyExaminerViewer::pan", "useless invokation" );
#endif // SO@GUI@_DEBUG
    return;
  }

#if SO@GUI@_DEBUG && 0
  SoDebugError::postInfo( "SoAnyExaminerViewer::pan",
     "was( %.3g, %.3g ) -> now( %.3g, %.3g )",
     prevpos[0], prevpos[1], thispos[0], thispos[1] );
#endif // SO@GUI@_DEBUG

  // Find projection points for the last and current mouse coordinates.
  SbViewVolume vv = cam->getViewVolume( viewer->getGLAspectRatio() );
  SbLine line;
  vv.projectPointToLine( thispos, line );
  SbVec3f current_planept;
  this->panningplane.intersect( line, current_planept );
  vv.projectPointToLine( prevpos, line );
  SbVec3f old_planept;
  this->panningplane.intersect( line, old_planept );

  // Reposition camera according to the vector difference between the
  // projected points.
  cam->position = cam->position.getValue() - (current_planept - old_planept);
} // pan()

// ************************************************************************

/*!
  \internal

  Dependent on the camera type this will either shrink or expand
  the height of the viewport (orthogonal camera) or move the
  camera closer or further away from the focal point in the scene.
*/

void
SoAnyExaminerViewer::zoom(
  const float diffvalue )
{
  SoCamera * cam = viewer->getCamera();
  if ( cam == NULL ) return; // can happen for empty scenegraph
  SoType t = cam->getTypeId();

  // This will be in the range of <0, ->>.
  float multiplicator = exp(diffvalue);

  if ( t.isDerivedFrom(SoOrthographicCamera::getClassTypeId()) ) {
    SoOrthographicCamera * oc = (SoOrthographicCamera *)cam;
    oc->height = oc->height.getValue() * multiplicator;
  } else if ( t.isDerivedFrom(SoPerspectiveCamera::getClassTypeId()) ) {
    float oldfocaldist = cam->focalDistance.getValue();
    cam->focalDistance = oldfocaldist * multiplicator;

    SbVec3f direction;
    cam->orientation.getValue().multVec(SbVec3f(0, 0, -1), direction);
    cam->position = cam->position.getValue() +
      (cam->focalDistance.getValue() - oldfocaldist) * -direction;
  } else {
    assert( 0 && "impossible" );
  }
} // zoom()

// *************************************************************************

/*!
  \internal

  Calculate a zoom/dolly factor from the difference of the current
  cursor position and the last.
*/

void
SoAnyExaminerViewer::zoomByCursor(
  const SbVec2f & thispos,
  const SbVec2f & prevpos )
{
  // There is no "geometrically correct" value, 20 just seems to give
  // about the right "feel".
  this->zoom( (thispos[1] - prevpos[1]) * 20.0f );
} // zoomByCursor()

// *************************************************************************

/*!
  This method is invoked so timing can be considered before the scene graph
  is redrawn.
*/

void
SoAnyExaminerViewer::actualRedraw(
  void )
{
  SbTime thisRedrawTime = SbTime::getTimeOfDay();
  unsigned long msecs =
    thisRedrawTime.getMsecValue() - this->prevRedrawTime.getMsecValue();
  this->prevRedrawTime = thisRedrawTime;

  if ( this->isAnimating() ) {
    SbRotation deltaRotation = this->spinRotation;
    deltaRotation.scaleAngle( (float) msecs / 200.0f );
    this->reorientCamera( deltaRotation );
  }
} // actualRedraw()

// *************************************************************************

/*!
  This method processes SoEvents instead of native GUI toolkit events, so
  the code can be shared between all the SoGUI libraries.
*/

SbBool
SoAnyExaminerViewer::processSoEvent(
  const SoEvent * const ev )
{
  if ( ! viewer->isViewing() ) // event is for scene graph
    return FALSE;

  const SoType type( ev->getTypeId() );

  const SbVec2f prevnormalized = this->lastmouseposition;
  const SbVec2f normalized(
    float(ev->getPosition()[0]) / float(viewer->getGLSize()[0]-1),
    float(ev->getPosition()[1]) / float(viewer->getGLSize()[1]-1) );
  this->lastmouseposition = normalized;

  // Mouse Button / Spaceball Button handling
  if ( type.isDerivedFrom( MOUSEBUTTON_EVENT ) ) {
    SoMouseButtonEvent * const event = (SoMouseButtonEvent *) ev;

    const int button = event->getButton();
    if ( event->getState() == SoButtonEvent::DOWN ) {
      if ( button == SoMouseButtonEvent::BUTTON1 ) {
        if ( viewer->isSeekMode() )
          return FALSE;
        if ( this->isAnimating() )
          this->stopAnimating();
        viewer->interactiveCountInc();
        this->clearLog();
        this->button1Down = TRUE;
        return TRUE; 
      }
      if ( button == SoMouseButtonEvent::BUTTON3 ) {
        if ( this->isAnimating() )
          this->stopAnimating();
        viewer->interactiveCountInc();
        this->button3Down = TRUE;
        SoCamera * const camera = viewer->getCamera();
        SbViewVolume volume = camera->getViewVolume( viewer->getGLAspectRatio() );
        this->panningplane = volume.getPlane( camera->focalDistance.getValue() );
        return TRUE; 
      }
 #ifdef HAVE_SOMOUSEBUTTONEVENT_BUTTONS
      if ( button == SoMouseButtonEvent::BUTTON4 ) {
        this->zoom( -0.1f );
        return TRUE;
      }
      if ( button == SoMouseButtonEvent::BUTTON5 ) {
        this->zoom( 0.1f );
        return TRUE; 
      }
#endif // HAVE_SOMOUSEBUTTONEVENT_BUTTONS
      return FALSE;
    }

    if ( event->getState() == SoButtonEvent::UP ) {
      if ( button == SoMouseButtonEvent::BUTTON1 ) {
        if ( viewer->isSeekMode() )
          return FALSE;
        this->button1Down = FALSE;
        if ( ! this->isAnimationEnabled() || this->log.historysize < 3 ) {
          viewer->interactiveCountDec();
          return TRUE;
        }
        const SbVec2s glsize( viewer->getGLSize() );
        SbVec3f from = this->spinprojector->project(
          SbVec2f( float(this->log.position[2][0]) / float(glsize[0]-1),
                   float(this->log.position[2][1]) / float(glsize[1]-1) ) );
        SbVec3f to = this->spinprojector->project( normalized );
        SbRotation rot = this->spinprojector->getRotation( from, to );

        float deltatime = this->log.time[0].getMsecValue() -
                          this->log.time[2].getMsecValue();
        rot.scaleAngle( 200.0f / deltatime );
        rot.invert();

        SbVec3f axis;
        float radians;
        rot.getValue( axis, radians );
        if ( radians < 0.005f ) {
          viewer->interactiveCountDec();
          return TRUE;
        }
        this->spinRotation = rot;
        this->spinanimating = TRUE;
        return TRUE; 
      }
      if ( button == SoMouseButtonEvent::BUTTON3 ) {
        this->button3Down = FALSE;
        viewer->interactiveCountDec();
        return TRUE;
      }
#ifdef HAVE_SOMOUSEBUTTONEVENT_BUTTONS
      if ( button == SoMouseButtonEvent::BUTTON4 )
        return TRUE; // correlates with zoom events
      if ( button == SoMouseButtonEvent::BUTTON5 )
        return TRUE; // correlates with zoom events
#endif // HAVE_SOMOUSEBUTTONEVENT_BUTTONS
      return FALSE;
    }
    return FALSE;
  }

  // Mouse Movement handling
  if ( type.isDerivedFrom( LOCATION2_EVENT ) ) {
    SoLocation2Event * const event = (SoLocation2Event *) ev;
    if ( this->button1Down && this->button3Down ) {
      this->zoomByCursor( normalized, prevnormalized );
      return TRUE;
    }
    if ( this->button1Down ) {
      this->addToLog( event->getPosition() );
      this->spin( normalized );
      return TRUE;
    }
    if ( this->button3Down ) {
      this->pan( normalized, prevnormalized );
      return TRUE;
    }
    return FALSE;
  }

  // Keyboard handling
  if ( type.isDerivedFrom( KEYBOARD_EVENT ) ) {
    SoKeyboardEvent * const event = (SoKeyboardEvent *) ev;
    if ( event->getState() == SoButtonEvent::DOWN ) {
      if ( event->getKey() == SoKeyboardEvent::LEFT_CONTROL
        || event->getKey() == SoKeyboardEvent::RIGHT_CONTROL ) {
        this->controlDown = TRUE;
      }
    }
    if ( event->getState() == SoButtonEvent::UP ) {
      if ( event->getKey() == SoKeyboardEvent::LEFT_CONTROL
        || event->getKey() == SoKeyboardEvent::RIGHT_CONTROL ) {
        this->controlDown = FALSE;
      }
    }
    return FALSE;
  }

  // Spaceball & Joystick handling
  if ( type.isDerivedFrom( MOTION3_EVENT ) ) {
    SoMotion3Event * const event = (SoMotion3Event *) ev;
    SoCamera * const camera = viewer->getCamera();
    if ( camera ) {
      if ( this->motion3OnCamera ) {
        camera->position =
          camera->position.getValue() + event->getTranslation();
        camera->orientation =
          camera->orientation.getValue() * event->getRotation();
        return TRUE;
      } else {
        // FIXME: move/rotate model
#if SO@GUI@_DEBUG
        SoDebugError::postInfo( "SoAnyExaminerViewer::processSoEvent",
          "SoMotion3Event for model movement is not implemented yet" );
#endif // SO@GUI@_DEBUG
        return TRUE;
      }
    }
    return FALSE;
  }

  return FALSE;
} // processSoEvent()

// *************************************************************************
// Methods used for spin animation tracking.

/*!
  This method "clears" the mouse location log, used for spin animation
  calculations.
*/

void
SoAnyExaminerViewer::clearLog(
  void )
{
  this->log.historysize = 0;
} // clearLog()

/*!
  This method adds another point to the mouse location log, used for spin
  animation calculations.
*/

void
SoAnyExaminerViewer::addToLog(
  const SbVec2s pos )
{
  if ( this->log.size <= 0 ) {
#if SO@GUI@_DEBUG
    SoDebugError::postInfo( "SoAnyExaminerViewer::addToLog", "no mouse log!" );
#endif // SO@GUI@_DEBUG
    return;
  }
  memmove( &(this->log.position[1]), &(this->log.position[0]), sizeof(SbVec2s)*(this->log.size-1) );
  memmove( &(this->log.time[1]), &(this->log.time[0]), sizeof(SbTime)*(this->log.size-1) );
  this->log.position[0] = pos;
  this->log.time[0] = SbTime::getTimeOfDay();
  if ( this->log.historysize < this->log.size )
    this->log.historysize += 1;
} // addToLog()

// *************************************************************************

/*!
  This method sets whether Motion3 events should affect the camera or the
  model.
*/

void
SoAnyExaminerViewer::setMotion3OnCamera(
  const SbBool enable )
{
  this->motion3OnCamera = enable;
} // setMotion3OnCamera()

/*!
  This method returns whether Motion3 events affects the camera or the
  model.
*/

SbBool
SoAnyExaminerViewer::getMotion3OnCamera(
  void ) const
{
  return this->motion3OnCamera;
} // getMotion3OnCamera()

// *************************************************************************

#if SO@GUI@_DEBUG
static const char * getSoAnyExaminerViewerRCSId(void) { return rcsid; }
#endif // SO@GUI@_DEBUG

